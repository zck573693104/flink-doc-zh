---
title: 方法库
nav-parent_id: graphs
nav-pos: 3
---
<!--
授权给Apache软件基金会(ASF)
或者更多贡献者许可协议。参见通知文件
与此工作一起分发，以获取更多信息
关于版权的所有权。ASF许可此文件
在Apache许可下，2.0版
“许可”);除非符合规定，否则您不能使用此文件
的许可证。你可于
http://www.apache.org/licenses/LICENSE-2.0
除非适用法律要求或经书面同意，
在授权下发布的软件是在
无任何保证或条件
善意的，明示的或暗示的。参见许可证
管理权限和限制的特定语言
根据许可证。
-->
Gelly拥有越来越多的图算法，可以方便地分析大型图。

* 这将被TOC替换
{:toc}

Gelly的库方法可以通过简单地调用输入图上的' run() '方法来使用:
<div class="codetabs" markdown="1">
<div data-lang="java" markdown="1">
{% highlight java %}
ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();

Graph<Long, Long, NullValue> graph = ...

// 运行标签传播30次，以检测输入图上的社区
DataSet<Vertex<Long, Long>> verticesWithCommunity = graph.run(new LabelPropagation<Long>(30));

// 打印结果
verticesWithCommunity.print();

{% endhighlight %}
</div>

<div data-lang="scala" markdown="1">
{% highlight scala %}
val env = ExecutionEnvironment.getExecutionEnvironment

val graph: Graph[java.lang.Long, java.lang.Long, NullValue] = ...

// 运行标签传播30次，以检测输入图上的社区
val verticesWithCommunity = graph.run(new LabelPropagation[java.lang.Long, java.lang.Long, NullValue](30))

// 打印结果
verticesWithCommunity.print()

{% endhighlight %}
</div>
</div>

## 社区发现

#### 概述
在图论中，群落是指内部连接良好，但与其他组连接稀疏的节点组。
该库方法是本文[面向大型网络实时社区检测]中描述的社区检测算法的实现(http://arxiv.org/pdf/0808.2633.pdf)。
#### 详情
该算法使用[散集-收集迭代](#散集-收集-迭代)实现。
最初，每个顶点被分配一个“Tuple2”，包含它的初值以及一个等于1.0的分数。
在每个迭代中，顶点将它们的标签和分数发送给它们的邻居。当接收到邻居的消息时，
顶点选择得分最高的标签，然后使用边缘值对其重新打分，
用户定义的跳衰减参数“delta”和超步数。
当顶点不再更新其值或迭代次数达到最大值时，算法收敛
是达到了。

#### 用法
该算法将一个“图”作为输入，包含任何顶点类型、“长”顶点值和“双”边值。它返回一个与输入类型相同的“图形”，
其中顶点值对应于共同体标签，即如果两个顶点具有相同的顶点值，则它们属于同一共同体。
构造函数接受两个参数:
* `maxIterations`: 要运行的最大迭代数。
* `delta`: 跳转衰减参数，默认值为0.5。
## 标签传播

#### 概述
这是[本文]中描述的著名标签传播算法的实现(http://journals.aps.org/pre/abstract/10.1103/PhysRevE.76.036106)。该算法通过在邻居之间迭代传播标签来发现图中的社区。与[Community Detection library method](# Community - Detection)不同，这个实现不使用与标签相关的分数。

#### 详情
该算法使用[散集-收集迭代](#散集-收集-迭代)实现。
标签的类型应该是“Comparable”，并使用输入“Graph”的顶点值初始化。
该算法通过传播标签来迭代细化发现的社区。在每次迭代中，取一个顶点
在相邻的标签中最常见的标签。如果出现并列(即两个或多个标签出现在
同样的频率)，算法选择更大的标签。当没有顶点改变其值或时，算法收敛
已达到最大迭代次数。注意，不同的初始化可能导致不同的结果。

#### 使用
该算法将具有“可比”顶点类型、“可比”顶点值类型和任意边值类型的“图”作为输入。
它返回一个顶点的“数据集”，其中顶点值对应于收敛后该顶点所属的社区。
构造函数接受一个参数:

* `maxIterations`: 要运行的最大迭代数。.

## 连通分支

#### 概述
这是一个实现弱连通分支算法。在收敛时，两个顶点属于
相同的分量，如果有一条路径从一个到另一个，不考虑边缘方向。

#### 详情
该算法使用[散集-收集迭代](#散集-收集-迭代)实现。
这个实现使用一个可比较的顶点值作为初始组件标识符(ID)。顶点传播他们的
每个迭代中的当前值。当一个顶点从它的邻居那里接收组件ID时，如果
当顶点不再更新其组件时，算法收敛
ID值或达到最大迭代次数时的值。
#### 使用
结果是一个顶点的“数据集”，其中顶点值对应于指定的组件。
构造函数接受一个参数:

* `maxIterations`: 要运行的最大迭代数。.

## GSA 连通分支

#### 概述
这是一个实现弱连通分支算法。在收敛时，两个顶点属于
相同的分量，如果有一条路径从一个到另一个，不考虑边缘方向。

#### 详情
该算法是使用[gather-sum-apply迭代](#gather-sum-apply-iteration)实现的。
这个实现使用一个可比较的顶点值作为初始组件标识符(ID)。在聚集阶段，每个
顶点收集它们相邻顶点的顶点值。在求和阶段，这些值中的最小值为
选中。在应用阶段，如果最小值小于新的顶点值，则算法将其设置为新的顶点值
当前值。当顶点不再更新其组件ID值或
已达到最大迭代次数。

#### 使用
结果是一个顶点的“数据集”，其中顶点值对应于指定的组件。
构造函数接受一个参数:

* `maxIterations`: 要运行的最大迭代数。.

## 单源最短路径

#### 概述
一种加权图的单源最短路径算法的实现。给定一个源顶点，算法计算从这个源到图中所有其他节点的最短路径。

#### 详情
该算法使用[散集-收集迭代](#散集-收集-迭代)实现。
在每次迭代中，一个顶点向它的邻居发送一条消息，其中包含它当前距离和连接这个顶点与邻居的边权值的和。当接收到候选距离消息时，顶点计算最小距离，如果发现更短的路径，则更新其值。如果一个顶点在超步骤中没有改变它的值，那么它就不会为下一个超步骤的邻居生成消息。计算在指定的最大超步数或没有值更新时终止
#### 使用
该算法将一个“图”作为输入，其中包含任何顶点类型和“双”边值。顶点值可以是任何类型，并且不被这个算法使用。顶点类型必须实现' equals() '。
输出是一个“数据集”的顶点，其中顶点值对应到给定源顶点的最小距离。
构造函数接受两个参数:
* `srcVertexId` 源顶点的顶点ID.
* `maxIterations`: 要运行的最大迭代数。.

## GSA单源最短路径

算法实现使用[gather-sum-apply iterations](#gather-sum-apply-iterations).

看 [Single Source Shortest Paths](#single-source-shortest-paths) 此库实现 详情 和 使用 信息.

## 三角形枚举器

#### 概述
这个库方法枚举输入图中出现的惟一三角形。三角形由三条边组成，三条边相互连接三个顶点。
此实现忽略边缘方向。

#### 详情
基本的三角形枚举算法将共享一个公共顶点并构建三元组的所有边分组，即，顶点的三组
是由两条边连接起来的。然后，过滤所有不存在关闭三角形的第三条边的三元组。
对于共享一个顶点的一组<i>n</i>边，构建的三元组的数量是二次的<i>((n*(n-1))/2)</i>。
因此，优化算法的一种方法是在输出度较小的顶点上对边进行分组，以减少三角形的数量。
该实现通过计算边缘顶点的输出度，并对边的小度顶点进行边的分组，扩展了基本算法。
#### 使用
该算法以一个有向图作为输入，输出一个“Tuple3”的“数据集”。顶点ID类型必须是“可比的”。
每个“Tuple3”对应一个三角形，其中的字段包含构成三角形的顶点的id。
## 摘要

#### 概述
的摘要算法计算压缩版本分组输入图的顶点和边的基础上
它们的值。在此过程中，该算法有助于揭示关于图中的模式和分布的见解。
一个可能的用例是社区的可视化，其中整个图太大，需要对其进行总结
基于存储在顶点上的社区标识符。

#### 详情
在生成的图中，每个顶点表示一组共享相同值的顶点。连接a的边
顶点本身，表示具有相同边值的所有边，这些边值连接来自相同顶点组的顶点。一个
输出图中不同顶点之间的边表示成员之间具有相同边值的所有边
输入图中不同的顶点组。
该算法采用Flink数据运算符实现。首先，顶点根据它们的值和一个代表符进行分组
从每个组中选择。对于任何边，源和目标顶点标识符都替换为相应的
具有代表性，并按源、目标和边缘值分组。输出顶点和边是从它们的
相应的分组。

#### 使用
该算法采用有向图、顶点图(可能还有边)属性图作为输入和输出，其中每个都有一个新的图
顶点表示一组顶点，每条边表示输入图中的一组边。此外,每个
输出图中的顶点和边缘存储公共组值和表示元素的数量。

## 集群使用

### 平均集群系数

#### 概述
平均聚类系数度量图的平均连通性。得分范围从0.0(之间没有边缘)
邻居)到1.0(完整的图)。

#### 详情
详细说明请参阅[局部聚类系数](#局部聚类系数)库方法
聚类系数。平均聚类系数是局部聚类系数得分的平均值
在所有顶点上至少有两个邻居。每个顶点，与度数无关，对于这个分数具有相同的权重。

#### 使用
详细说明请参阅[局部聚类系数](#局部聚类系数)库方法
聚类系数。平均聚类系数是局部聚类系数得分的平均值
在所有顶点上至少有两个邻居。每个顶点，与度数无关，对于这个分数具有相同的权重。提供有向和无向变体。分析方法将一个简单的图形作为输入，然后输出一个“分析结果”
包含图的顶点总数和平均聚类系数。图形ID类型必须是
“可比性”和“复制”。

* `setParallelism`: override the parallelism of operators processing small amounts of data

### 全局聚类系数

#### 概述
全局聚类系数度量图的连通性。得分范围从0.0(之间没有边缘)
邻居)到1.0(完整的图)。

#### 详情
详细说明请参阅[局部聚类系数](#局部聚类系数)库方法
聚类系数。全局聚类系数是连通邻域在整个图上的比值。
度高的顶点对于这个分数有更大的权重，因为相邻对的计数是二次的
学位。

#### 使用
提供有向和无向变体。分析方法将一个简单的图形作为输入，然后输出一个“分析结果”
包含图中三胞胎和三角形的总数。result类提供了计算
全局聚类系数得分。图形ID类型必须是“可比较的”和“可复制的”。
*“setParallelism”:覆盖处理少量数据的操作符的并行性

### 当地的聚类系数

#### 概述
局部聚类系数度量每个顶点邻域的连通性。得分范围从0.0 (no
邻居之间的边缘)到1.0(邻居是一个小团体)。

#### 详情
顶点相邻边之间的边是三角形。计算邻居之间的边与计算
包含顶点的三角形数。聚类系数得分是相邻边的个数
除以邻边之间的潜在边数。
有关三角形枚举的详细说明，请参阅[Triangle Listing](# Triangle - Listing)库方法。

#### 使用
顶点相邻边之间的边是三角形。计算邻居之间的边等价于计算有向变量和无向变量。该算法以一个简单的图形作为输入和输出的“数据集”
' UnaryResult '包含顶点ID、顶点度数和包含顶点的三角形数。结果类
提供了一种计算局部聚类系数得分的方法。图形ID类型必须是“Comparable”和
“复制”。
* ' setincludezerodegreever格':包括顶点的结果与程度为零
*“setParallelism”:覆盖处理少量数据的操作符的并行性
包含顶点的三角形数。聚类系数得分是相邻边的个数
除以邻边之间的潜在边数。
有关三角形枚举的详细说明，请参阅[Triangle Listing](# Triangle - Listing)库方法。

### Triadic Census

#### 概述

三元组由图中的任意三个顶点组成。每个三元组包含三对可以连接的顶点
或无关的。[Triadic Census](http://vlado.fmf.uni-lj.si/pub/networks/doc/triads/triads.pdf)统计了
在图中出现每种类型的三元组。
#### 详情
该分析计算了四种无向三元组(由0、1、2或3条连接边组成)或16种有向三元组
通过计算[Triangle Listing](# Triangle - Listing)中的三角形(# Triangle Metrics)和运行[Vertex Metrics](# Vertex - Metrics)来输入
得到三胞胎和边的数目。然后从三重计数中减去三角形计数，三角形和
从边缘计数中删除三重计数。

#### 使用
提供有向和无向变体。分析以一个简单的图形作为输入和输出
“AnalyticResult”，带有访问器方法，用于查询每个三元组类型的计数。图形ID类型必须是
“可比性”和“复制”。
*“setParallelism”:覆盖处理少量数据的操作符的并行性

### Triangle Listing

#### 概述
枚举图中的所有三角形。三角形由三条边组成，三条边把三个顶点连接成三角形的小圈
尺寸3。
#### 详情
三角形是通过将开放三联体(具有公共邻居的两条边)连接到三联体端点上的边而列出的。
此实现使用来自
[Schank的算法](http://i11www.iti.uni-karlsruhe.de/extra/publications/sw-fclt-05_t.pdf)
高度顶点。因为每个三角形只需要列出一次，所以从最低次顶点生成三联。
这大大减少了生成的三胞胎的数量，这是二次的顶点度。

#### 使用
提供有向和无向变体。该算法以一个简单的图形作为输入和输出的“数据集”
包含三个三角形顶点的“aryresult”，对于有向算法，每个顶点都有一个位掩码
连接三个顶点的六条可能的边。图形ID类型必须是“可比较的”和“可复制的”。
*“setParallelism”:覆盖处理少量数据的操作符的并行性
* ' setsorttrianglever':对三角形列表进行规范化，以便对每个结果(K0, K1, K2)的顶点id排序为K0 < K1 < K2

## 链接分析

### 链接分析

#### 概述
[超连结引发的主题搜寻](http://www.cs.cornell.edu/home/kleinber/auth.pdf)
为有向图中的每个顶点计算两个相互依赖的分数。好的集线器是指向很多的集线器
好的权威和好的权威是由许多好的中心所指向的。
# # # #详情
每个顶点都被分配相同的初始集线器和权限得分。然后，算法迭代地更新分数
直到终止。在每个迭代过程中，新的中心得分从权威得分计算，然后是新的权威
分数是根据新的hub分数计算的。然后对分数进行标准化，并可选地进行收敛性测试。
点击量类似于[PageRank](# PageRank)，但顶点得分会全部发送给每个邻居，而在PageRank中
顶点得分首先除以邻居的数量。
# # # #使用
该算法以一个简单的有向图作为输入和输出包含顶点ID的“UnaryResult”的“DataSet”，
hub评分和authority评分。终止由迭代次数和/或收敛阈值来配置
所有顶点得分变化的迭代和。
* ' setincludezerodegreever格':是否在迭代计算中包含0度顶点
* ' setParallelism ':覆盖操作符parallelism
# # #网页排名
# # # #概述
[PageRank](https://en.wikipedia.org/wiki/PageRank)是第一个用于对web搜索引擎进行排名的算法
结果。目前，该算法和许多变体被用于各种图形应用领域。PageRank的概念是
重要的或相关的顶点倾向于链接到其他重要的顶点。
# # # #详情
算法在迭代中运行，其中页面将它们的得分分配给它们的邻居(它们有链接的页面)
然后根据他们收到的值的总和更新他们的分数。为了考虑a的重要性
从一个页面到另一个页面的链接，分数除以源页面的外链接总数。因此，一页用
10个链接将其分数的1/10分发给每个邻居，而一个有100个链接的页面将其分数的1/100分发给每个邻居
给每个相邻的页面打分。
#### 使用
该算法采用有向图作为输入和输出“数据集”，其中每个“结果”包含顶点ID和
网页排名得分。终止配置了最大迭代次数和/或收敛阈值
计算迭代之间每个顶点的得分变化之和。
* ' setParallelism ':覆盖操作符parallelism
# #规
# # #顶点指标
# # # #概述
本图分析计算了有向图和无向图的以下统计数据:
-顶点数
-边数
——平均程度
-三胞胎的数目
——最大程度
-最大三胞胎数目
对于有向图，还计算了以下统计数据:
-单向边数
-双向边数
-最大出度
-最大程度
# # # #详情
这些统计数据是通过' degree.annotate.direct '生成的顶点度数来计算的。VertexDegrees”或
“degree.annotate.undirected.VertexDegree”。
# # # #使用
提供有向和无向变体。分析方法将一个简单的图形作为输入，然后输出一个“分析结果”
用于计算统计信息的访问器方法。图形ID类型必须是“Comparable”。
* ' setincludezerodegreever格':包括顶点的结果与程度为零
* ' setParallelism ':覆盖操作符parallelism
*“setReduceOnTargetId”(仅无定向):可以从边缘源id或目标id计算度数。默认情况下计算源id。如果按照目标ID对输入边缘列表进行排序，则减少目标ID可以优化算法
# # #边缘度量
# # # #概述
此图分析计算了以下统计数据:
-三角形三胞胎的数目
-矩形三胞胎的数量
-三角形三胞胎的最大数量
-矩形三胞胎的最大数量

#### 详情
这些统计数据是根据“degree.annotate.direct”生成的边缘度计算的。EdgeDegreesPair”或
“degree.annotate.undirected。并按顶点分组。
# # # #使用
提供有向和无向变体。分析方法将一个简单的图形作为输入，然后输出一个“分析结果”
用于计算统计信息的访问器方法。图形ID类型必须是“Comparable”。
* ' setParallelism ':覆盖操作符parallelism
*“setReduceOnTargetId”(仅无定向):可以从边缘源id或目标id计算度数。默认情况下计算源id。如果按照目标ID对输入边缘列表进行排序，则减少目标ID可以优化算法
# #相似
# # # Adamic-Adar
# # # #概述
Adamic-Adar将顶点对之间的相似性度量为共享度的逆对数之和
邻居。分数是非负的、无界的。度越高的顶点对整体影响越大，但影响越小
对每一对邻居都有影响。
# # # #详情
该算法首先用顶点度数的对数的倒数来标注每个顶点，然后将这个分数连接起来
通过源顶点到边上。在源顶点上分组，每对邻居都与顶点得分一起发出。
对顶点对进行分组，得到亚当-阿达尔评分。
参见[Jaccard索引](# Jaccard - Index)库方法获得类似的算法。
# # # #使用
该算法以一个简单的无向图作为输入和输出包含两个顶点的“BinaryResult”的“DataSet”
id和adam - adar相似度评分。图形ID类型必须是“可复制的”。
*“setMinimumRatio”:过滤掉低于给定比率乘以平均分数的Adamic-Adar分数
*“setMinimumScore”:过滤掉低于给定最小值的Adamic-Adar分数
*“setParallelism”:覆盖处理少量数据的操作符的并行性
# # # Jaccard指数
# # # #概述
Jaccard索引度量顶点邻域之间的相似性，并计算为共享邻域的数量
除以不同邻居的数量。得分范围从0.0(没有共享邻居)到1.0(所有邻居都是)
共享)。
# # # #详情
计算顶点对的共享邻居数等价于计算长度为2的连接路径。的数量
不同的邻域通过存储顶点对的度数和并减去共享的数来计算
邻域，它们在度数和中被重复计算。
该算法首先用目标顶点的度数标注每条边。在源顶点上分组，每对
邻域以次和发出。按顶点对分组，计算共享邻居。
# # # #使用
该算法以一个简单的无向图作为输入和输出一个包含两个顶点id的元组“数据集”，
共享邻居的数量，以及不同邻居的数量。result类提供了计算
Jaccard指数得分。图形ID类型必须是“可复制的”。
* ' setMaximumScore ':过滤掉Jaccard索引分数大于或等于给定的最大分数
* ' setMinimumScore ':过滤掉Jaccard索引分数低于给定的最小分数
*“setParallelism”:覆盖处理少量数据的操作符的并行性

{% top %}
